---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/store/billStore.ts
  - src/store/billStore.test.ts
autonomous: true
requirements:
  - ASGN-02
  - TPTX-02
  - TPTX-04
  - SUMM-02

must_haves:
  truths:
    - "Zustand store holds only input data — no derived totals stored in state"
    - "Store actions correctly mutate bill state: add/remove people, add/remove/edit items, assign items, set tip, set tax"
    - "getResult() computes fresh results by calling the engine on current state — not cached or stored"
    - "Removing a person redistributes their shared items and unassigns sole-owned items"
    - "Store tests use zustand/vanilla createStore for isolation — no state leaks between tests"
    - "Integration tests verify that store actions + engine produce correct end-to-end results"
  artifacts:
    - path: "src/store/billStore.ts"
      provides: "Zustand store with immer middleware: bill state, actions, getResult() derived computation"
      exports: ["useBillStore", "createBillStore"]
      min_lines: 60
    - path: "src/store/billStore.test.ts"
      provides: "Store unit tests and integration tests using zustand/vanilla"
      min_lines: 100
  key_links:
    - from: "src/store/billStore.ts"
      to: "src/engine/engine.ts"
      via: "import computeSplit"
      pattern: "import.*computeSplit.*from.*engine"
    - from: "src/store/billStore.ts"
      to: "src/engine/types.ts"
      via: "type imports for BillConfig, EngineResult"
      pattern: "import.*type.*(BillConfig|EngineResult|Item|Person)"
    - from: "src/store/billStore.test.ts"
      to: "src/store/billStore.ts"
      via: "import createBillStore for isolated testing"
      pattern: "import.*createBillStore.*from.*billStore"
---

<objective>
Build the Zustand store as a thin wrapper over the tested engine. The store holds input-only state (people, items, assignments, tip/tax config), provides mutation actions, and exposes a `getResult()` method that calls `computeSplit()` on the current state. No derived data is stored — only computed on read.

Purpose: Complete the Phase 1 architecture by wiring the tested engine into state management. Store-level integration tests verify that the full pipeline (user action -> state mutation -> engine computation -> correct result) works end-to-end. This also validates the person-removal redistribution logic and the per-split includeZeroFoodPeople toggle in a stateful context.

Output: `src/store/billStore.ts` (Zustand store) and `src/store/billStore.test.ts` (unit + integration tests), all tests green.
</objective>

<execution_context>
@/Users/shantnupatil/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantnupatil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/engine/types.ts
@src/engine/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand store with immer middleware and all bill actions</name>
  <files>src/store/billStore.ts</files>
  <action>
    Create `src/store/billStore.ts` with Zustand 5 + immer middleware.

    **Store state (input only — no derived data):**
    ```typescript
    interface BillState {
      config: BillConfig;
      // Actions
      addPerson: (name: string) => void;
      removePerson: (personId: PersonId) => void;
      updatePerson: (personId: PersonId, updates: Partial<Pick<Person, 'name'>>) => void;
      addItem: (label: string, priceCents: Cents, quantity?: number) => void;
      removeItem: (itemId: ItemId) => void;
      updateItem: (itemId: ItemId, updates: Partial<Pick<Item, 'label' | 'priceCents' | 'quantity'>>) => void;
      assignItem: (itemId: ItemId, personIds: PersonId[]) => void;
      setTip: (amountCents: Cents, method: SplitMethod, includeZeroFoodPeople: boolean) => void;
      setTax: (amountCents: Cents, method: SplitMethod, includeZeroFoodPeople: boolean) => void;
      reset: () => void;
      // Derived (computed on read, NEVER stored)
      getResult: () => EngineResult;
    }
    ```

    **Initial state:**
    ```typescript
    const initialConfig: BillConfig = {
      items: [],
      people: [],
      assignments: {},
      tip: { amountCents: cents(0), method: 'equal', includeZeroFoodPeople: false },
      tax: { amountCents: cents(0), method: 'equal', includeZeroFoodPeople: false },
    };
    ```

    **Action implementations (using immer for mutable-style updates):**

    - `addPerson(name)`: Push new Person with `crypto.randomUUID()` id to `state.config.people`.
    - `removePerson(personId)`: Remove person from `state.config.people`. For each item in `state.config.assignments`, remove the personId. If an item's assignment array becomes empty AND the person was one of the sharers, that item becomes unassigned (this is correct per locked decision: "if they were the sole owner, items become unassigned which blocks calculation"). Do NOT auto-delete the item — just leave it unassigned so the engine returns the unassigned_items error.
    - `updatePerson(personId, updates)`: Find person by id, apply partial updates.
    - `addItem(label, priceCents, quantity)`: Push new Item with `crypto.randomUUID()` id. Initialize `assignments[itemId] = []` (unassigned).
    - `removeItem(itemId)`: Remove item from `state.config.items`. Delete `state.config.assignments[itemId]`.
    - `updateItem(itemId, updates)`: Find item by id, apply partial updates.
    - `assignItem(itemId, personIds)`: Set `state.config.assignments[itemId] = personIds`.
    - `setTip(amountCents, method, includeZeroFoodPeople)`: Update `state.config.tip`.
    - `setTax(amountCents, method, includeZeroFoodPeople)`: Update `state.config.tax`.
    - `reset()`: Set `state.config` back to `initialConfig` (deep copy).
    - `getResult()`: Call `computeSplit(get().config)` and return the result. Not stored in state.

    **Two exports:**
    1. `useBillStore` — React hook version via `create<BillState>()(immer(...))`
    2. `createBillStore` — factory function using `createStore` from `zustand/vanilla` for testing. This creates an isolated store instance per call, preventing test state leakage.

    Use `create` from `'zustand'` for `useBillStore` and `createStore` from `'zustand/vanilla'` for `createBillStore`. Both use the same immer-wrapped state creator function (extract it to a shared variable).

    Per Zustand 5: use double-parentheses pattern `create<BillState>()(immer((set, get) => ({...})))`.

    Import `computeSplit` from `'../engine/engine'` and types from `'../engine/types'`.
  </action>
  <verify>
    Run `npx tsc --noEmit` — zero type errors.
    Verify `useBillStore` and `createBillStore` are exported.
    Verify `getResult` calls `computeSplit` (not storing the result in state).
  </verify>
  <done>
    `src/store/billStore.ts` exports `useBillStore` (React hook) and `createBillStore` (vanilla factory for tests). Store holds only input data. `getResult()` computes fresh results via the engine. All actions implemented with immer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write store unit tests and integration tests using zustand/vanilla</name>
  <files>src/store/billStore.test.ts</files>
  <action>
    Create `src/store/billStore.test.ts` using `createBillStore` from the store module (zustand/vanilla factory). Each test creates a fresh store instance via `createBillStore()` in a `beforeEach` to prevent state leakage between tests.

    **Unit tests for store actions:**

    1. `addPerson` — adds a person with name and generated id
    2. `addPerson` twice — two people in the list
    3. `removePerson` — person removed from people list
    4. `removePerson` — person removed from all item assignments
    5. `removePerson` sole owner — item assignment becomes empty array (unassigned)
    6. `removePerson` shared owner — other sharers remain
    7. `updatePerson` — name updated
    8. `addItem` — item added with correct fields, assignment initialized to []
    9. `removeItem` — item removed from items list and assignments
    10. `updateItem` — label and price updated
    11. `assignItem` — sets assignment for item
    12. `setTip` — updates tip config (amount, method, includeZeroFoodPeople)
    13. `setTax` — updates tax config
    14. `reset` — returns to initial empty state

    **Integration tests (store actions -> engine result):**

    15. Add 2 people, add 1 item ($10), assign to both, set tip $3 equal, tax $2 equal:
        - `getResult()` returns ok: true
        - Person A food: 500, tip: 150, tax: 100
        - Person B food: 500, tip: 150, tax: 100

    16. Add 3 people, add shared item ($10 to A+B) and individual item ($7 to C), proportional tip $3:
        - A food: 500, B food: 500, C food: 700
        - Proportional tip: A gets 3*500/1700, B gets 3*500/1700, C gets 3*700/1700 (use largest-remainder)

    17. Unassigned item blocks calculation:
        - Add item without assigning -> getResult() returns { ok: false, reason: 'unassigned_items' }

    18. Person with no food, includeZeroFoodPeople = false:
        - Add 2 people (A, B), add item assigned to A only, set tip $2 equal with includeZeroFoodPeople=false
        - B should get 0 tip

    19. Person with no food, includeZeroFoodPeople = true:
        - Same setup but includeZeroFoodPeople=true
        - B should get their share of tip

    20. Remove person then getResult — redistribution works:
        - Add 3 people, assign item to A+B, remove B
        - Item now assigned to A only, getResult works

    21. No derived data stored:
        - After calling getResult(), inspect store state — no `result` or `personResults` field exists
        - Only `config` field exists in state

    All tests use `store.getState()` to read state and `store.getState().actionName()` to call actions (zustand/vanilla pattern).
  </action>
  <verify>
    Run `npx vitest run src/store/billStore.test.ts` — ALL tests pass.
    Run `npx vitest run` — ALL tests pass (both engine and store).
    Run `npx tsc --noEmit` — zero type errors.
  </verify>
  <done>
    `src/store/billStore.test.ts` has 20+ test cases covering all store actions and integration scenarios. All tests pass. Combined with engine tests, the full suite validates every Phase 1 success criterion: shared items (ASGN-02), tip split methods (TPTX-02), tax split methods (TPTX-04), rounding with surplus (SUMM-02), unassigned item blocking, and per-split includeZeroFoodPeople toggle. Zustand store holds only input data with no stored derived totals.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — ALL tests pass (engine + store combined)
2. `npx tsc --noEmit` — zero type errors
3. Store state contains only `config` — no derived data
4. `getResult()` calls `computeSplit` fresh each time
5. Person removal correctly redistributes assignments
6. Phase 1 success criteria fully verified:
   - SC1: Test suite passes for party sizes 1-10 across all split methods (engine tests)
   - SC2: Sum of per-person shares equals tip/tax total — no penny gaps (engine invariant tests)
   - SC3: Each person's total rounded up with surplus accessible (engine + store integration)
   - SC4: Shared items split among only sharers (engine + store integration)
   - SC5: Store holds only input data — getResult() is derived (store unit test)
</verification>

<success_criteria>
- `src/store/billStore.ts` exports useBillStore and createBillStore
- `src/store/billStore.test.ts` has 20+ passing tests
- Full test suite (engine + store) passes with `npx vitest run`
- No stored derived totals in Zustand state
- Person removal correctly handles redistribution
- All four Phase 1 requirements (ASGN-02, TPTX-02, TPTX-04, SUMM-02) verified through integration tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
