---
phase: 06-persistence-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - src/store/historyStore.ts
  - src/store/historyStore.test.ts
  - src/store/billStore.ts
  - src/store/billStore.test.ts
autonomous: true
requirements:
  - PERS-01
  - PERS-02
  - PERS-03

must_haves:
  truths:
    - "User refreshes the page mid-entry and all people, items, assignments, tip, and tax are exactly as left"
    - "User taps Save Split and the completed bill is added to persistent history that survives closing and reopening the browser"
    - "Both stores have version: 1 and migrate stubs so future schema changes have an upgrade path"
    - "App does not crash in Safari Private Browsing mode — storage errors are silently caught"
    - "History is capped at 50 entries to prevent localStorage quota errors"
  artifacts:
    - path: "src/store/historyStore.ts"
      provides: "Persist-wrapped Zustand store for saved bill history"
      exports: ["useHistoryStore", "createHistoryStore", "SavedSplitId", "savedSplitId", "SavedSplit", "HistoryState"]
    - path: "src/store/historyStore.test.ts"
      provides: "Unit tests for history store actions using vanilla factory"
      contains: "createHistoryStore"
    - path: "src/store/billStore.ts"
      provides: "Modified bill store with persist middleware, currentSplitId, loadConfig, setCurrentSplitId"
      exports: ["useBillStore", "createBillStore", "BillState"]
    - path: "src/store/billStore.test.ts"
      provides: "Updated tests verifying new actions and existing tests still pass"
      contains: "loadConfig"
  key_links:
    - from: "src/store/historyStore.ts"
      to: "src/storage/localStorageAdapter.ts"
      via: "import safeLocalStorage for createJSONStorage"
      pattern: "import.*safeLocalStorage.*from.*storage/localStorageAdapter"
    - from: "src/store/historyStore.ts"
      to: "src/engine/types.ts"
      via: "import BillConfig type for SavedSplit.config"
      pattern: "import.*BillConfig.*from.*engine/types"
    - from: "src/store/billStore.ts"
      to: "src/storage/localStorageAdapter.ts"
      via: "import safeLocalStorage for createJSONStorage"
      pattern: "import.*safeLocalStorage.*from.*storage/localStorageAdapter"
    - from: "src/store/billStore.ts"
      to: "zustand/middleware"
      via: "persist and createJSONStorage middleware imports"
      pattern: "import.*persist.*createJSONStorage.*from.*zustand/middleware"
---

<objective>
Create the history store and add persist middleware to the bill store, completing the localStorage persistence layer.

Purpose: This plan delivers the two core persistence capabilities: (1) the active bill auto-saves through page refresh via Zustand persist on useBillStore (PERS-01), and (2) completed bills can be explicitly saved to a new useHistoryStore that persists to its own localStorage key (PERS-02). Both stores ship with version: 1 and migrate stubs for future schema safety (PERS-03).

Output: Two new/modified store files with persist middleware, plus test files for both.
</objective>

<execution_context>
@/Users/shantnupatil/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantnupatil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-persistence-foundation/06-RESEARCH.md
@.planning/phases/06-persistence-foundation/06-01-SUMMARY.md

@src/store/billStore.ts
@src/store/billStore.test.ts
@src/engine/types.ts
@src/storage/localStorageAdapter.ts
@src/storage/deserializeBillConfig.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useHistoryStore with persist middleware and unit tests</name>
  <files>
    src/store/historyStore.ts
    src/store/historyStore.test.ts
  </files>
  <action>
**1. Create `src/store/historyStore.ts`:**

Follow the RESEARCH.md Pattern 4 implementation exactly. Key details:

- Import `create` from `zustand`, `createStore` from `zustand/vanilla`, `persist`/`createJSONStorage` from `zustand/middleware`, `immer` from `zustand/middleware/immer`
- Import `safeLocalStorage` from `../storage/localStorageAdapter`
- Import `BillConfig` type from `../engine/types`

Define and export:
- `SavedSplitId` branded type: `string & { readonly __brand: 'SavedSplitId' }`
- `savedSplitId(s: string): SavedSplitId` constructor helper
- `SavedSplit` interface: `{ id: SavedSplitId; savedAt: number; config: BillConfig }`
- `HistoryState` interface: `{ splits: SavedSplit[]; save; update; remove; restore }`

Implement `historyStateCreator` with:
- `splits: []` initial state
- `save(config: BillConfig): SavedSplitId` — generates UUID via `savedSplitId(crypto.randomUUID())`, unshifts to `splits`, enforces 50-entry cap by slicing, returns id
- `update(id: SavedSplitId, config: BillConfig)` — finds split by id, updates config and savedAt
- `remove(id: SavedSplitId)` — filters out split by id
- `restore(split: SavedSplit)` — idempotent re-insert (skip if id already present), unshift and re-sort by savedAt DESC

Export `useHistoryStore` using `create<HistoryState>()(persist(immer(historyStateCreator), options))`:
- `name: 'bs-history'`
- `storage: createJSONStorage(() => safeLocalStorage)`
- `version: 1`
- `migrate(persisted: unknown, _fromVersion: number)` — identity migration, returns `persisted as HistoryState`

CRITICAL middleware order: `persist(immer(creator))` — persist MUST wrap immer, NOT the reverse. The wrong order causes persist to silently capture only initial state.

Export `createHistoryStore()` factory for tests — uses `immer(historyStateCreator)` WITHOUT persist middleware (Node test environment has no localStorage). This mirrors the existing `createBillStore()` pattern.

**2. Create `src/store/historyStore.test.ts`:**

This is a plain `node` environment test (no jsdom needed). Import `createHistoryStore` and branded type constructors.

Test cases:
1. **save() adds entry and returns id** — save a BillConfig, assert `splits.length === 1`, assert returned id is a string, assert `splits[0].config` matches input
2. **save() caps at 50 entries** — save 51 entries in a loop, assert `splits.length === 50`, assert the oldest entry (51st) was dropped
3. **update() modifies existing entry** — save a config, then update with a different config, assert `splits[0].config` reflects the new config and `savedAt` changed
4. **remove() deletes by id** — save 2 entries, remove the first, assert `splits.length === 1` and remaining is the second
5. **restore() re-inserts with original id** — save an entry, capture the SavedSplit, remove it, restore it, assert `splits.length === 1` and id matches original
6. **restore() is idempotent** — save an entry, restore same entry again, assert `splits.length === 1` (not 2)

Use `createHistoryStore()` vanilla factory for each test. Create a helper function that builds a minimal valid BillConfig for test data.
  </action>
  <verify>
Run `npx vitest run src/store/historyStore.test.ts` — all 6 tests pass.
Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
historyStore.ts exports useHistoryStore (persist-wrapped) and createHistoryStore (vanilla for tests). All 6 unit tests pass, verifying save/update/remove/restore/cap/idempotency. Middleware order is persist(immer(creator)). Schema version is 1 with migrate stub.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add persist middleware and new actions to billStore</name>
  <files>
    src/store/billStore.ts
    src/store/billStore.test.ts
  </files>
  <action>
**1. Modify `src/store/billStore.ts`:**

Add these imports at the top:
- `import { persist, createJSONStorage } from 'zustand/middleware';`
- `import { safeLocalStorage } from '../storage/localStorageAdapter';`
- `import type { SavedSplitId } from './historyStore';`

Add to `BillState` interface:
- `currentSplitId: SavedSplitId | null;` — null = new unsaved split, non-null = editing a saved split
- `setCurrentSplitId: (id: SavedSplitId | null) => void;`
- `loadConfig: (config: BillConfig) => void;` — replaces entire config from a saved split

Add to `stateCreator`:
- `currentSplitId: null,` in initial state
- `setCurrentSplitId(id) { set((state) => { state.currentSplitId = id; }); }`
- `loadConfig(config) { set((state) => { state.config = config; }); }`

Update `reset()` to also clear `currentSplitId`:
```
reset() {
  set((state) => {
    state.config = { items: [], people: [], assignments: {}, tip: { amountCents: cents(0), method: 'equal', includeZeroFoodPeople: false }, tax: { amountCents: cents(0), method: 'equal', includeZeroFoodPeople: false } };
    state.currentSplitId = null;
  });
},
```

Change the `useBillStore` export to wrap with persist middleware:
```typescript
export const useBillStore = create<BillState>()(
  persist(
    immer(stateCreator),
    {
      name: 'bill-splitter-active',
      storage: createJSONStorage(() => safeLocalStorage),
      version: 1,
      partialize: (state) => ({ config: state.config }),
      migrate(persisted: unknown, _fromVersion: number) {
        return persisted as Pick<BillState, 'config'>;
      },
    }
  )
);
```

CRITICAL: `partialize` must select ONLY `config`. Do NOT include `currentSplitId` (it always starts null on refresh) and do NOT include action functions (they are not serializable).

CRITICAL middleware order: `persist(immer(stateCreator))` — persist wraps immer. Not the reverse.

Leave `createBillStore()` unchanged — NO persist in the test factory. It stays as `createStore<BillState>()(immer(stateCreator))`.

**2. Update `src/store/billStore.test.ts`:**

Read the existing test file first. Add these new test cases (do not remove or modify any existing tests):

1. **loadConfig replaces entire config** — Create a store, add some people/items, then call `loadConfig` with a completely different config. Assert the store's config matches the loaded config exactly.

2. **setCurrentSplitId sets and clears** — Create a store, call `setCurrentSplitId` with a mock SavedSplitId string, assert it is set. Call `setCurrentSplitId(null)`, assert it is null.

3. **reset clears currentSplitId** — Create a store, set `currentSplitId` to a value, call `reset()`, assert `currentSplitId` is null and config is empty.

4. **Existing tests still pass** — Do NOT modify any existing test. The vanilla factory (`createBillStore`) has no persist middleware, so all existing tests work unchanged in the `node` environment.

Import `savedSplitId` from `./historyStore` if needed for creating mock IDs, or just cast a string directly for test simplicity.
  </action>
  <verify>
Run `npx vitest run src/store/billStore.test.ts` — ALL tests pass (existing + new).
Run `npx vitest run` — full test suite passes with zero failures.
Run `npx tsc --noEmit` — no type errors.
  </verify>
  <done>
billStore.ts has persist middleware wrapping immer with partialize on config only. New actions loadConfig, setCurrentSplitId, and updated reset are working. All existing tests pass unchanged. Three new tests verify the new functionality. Schema version is 1 with migrate stub. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — full project test suite passes (all existing + all new tests)
2. `npx tsc --noEmit` — zero type errors across the project
3. `npm run build` — production build succeeds
4. Verify in browser DevTools (Application > Local Storage):
   - Load the app, add a person and item — `bill-splitter-active` key appears in localStorage with `config` data
   - Refresh the page — person and item are still present (PERS-01)
   - Open browser console, run `useHistoryStore.getState().save(useBillStore.getState().config)` — `bs-history` key appears (PERS-02)
   - Both localStorage values contain `"version":1` (PERS-03)
</verification>

<success_criteria>
- Active bill persists through page refresh via Zustand persist on useBillStore (PERS-01)
- History store can save completed bills to localStorage with a single action (PERS-02)
- Both stores have version: 1 and migrate stubs for future schema changes (PERS-03)
- History is capped at 50 entries
- App does not crash with localStorage errors (safeLocalStorage adapter)
- All existing tests pass without modification
- Full test suite (existing + new) passes
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-persistence-foundation/06-02-SUMMARY.md`
</output>
