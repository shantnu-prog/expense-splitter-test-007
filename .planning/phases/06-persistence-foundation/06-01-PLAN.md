---
phase: 06-persistence-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/localStorageAdapter.ts
  - src/storage/deserializeBillConfig.ts
  - src/storage/deserializeBillConfig.test.ts
autonomous: true
requirements:
  - PERS-03

must_haves:
  truths:
    - "localStorage read/write errors are caught and never crash the app"
    - "BillConfig survives JSON.stringify -> JSON.parse -> deserializeBillConfig round-trip with all branded types intact"
    - "computeSplit produces identical results from deserialized config as from original config"
  artifacts:
    - path: "src/storage/localStorageAdapter.ts"
      provides: "Safe try/catch wrappers for localStorage getItem/setItem/removeItem"
      exports: ["safeLocalStorage"]
    - path: "src/storage/deserializeBillConfig.ts"
      provides: "Single parse boundary re-applying branded type constructors after JSON.parse"
      exports: ["deserializeBillConfig"]
    - path: "src/storage/deserializeBillConfig.test.ts"
      provides: "Round-trip test verifying branded types survive JSON serialization"
      contains: "deserializeBillConfig"
  key_links:
    - from: "src/storage/deserializeBillConfig.ts"
      to: "src/engine/types.ts"
      via: "import of cents, personId, itemId constructors"
      pattern: "import.*cents.*personId.*itemId.*from.*engine/types"
    - from: "src/storage/localStorageAdapter.ts"
      to: "localStorage"
      via: "try/catch wrapped native API calls"
      pattern: "localStorage\\.(getItem|setItem|removeItem)"
---

<objective>
Create the safe localStorage adapter and branded-type deserialization layer that all Phase 6 persist middleware depends on.

Purpose: Zustand persist middleware needs a safe storage backend that handles QuotaExceededError (Safari Private Browsing, quota full) without crashing the app. Additionally, branded types (Cents, PersonId, ItemId) lose their TypeScript brand on JSON.parse -- a dedicated deserializeBillConfig function must re-apply constructor helpers at the single parse boundary to maintain type safety.

Output: Two source files (localStorageAdapter.ts, deserializeBillConfig.ts) and one test file proving the round-trip correctness.
</objective>

<execution_context>
@/Users/shantnupatil/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantnupatil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-persistence-foundation/06-RESEARCH.md

@src/engine/types.ts
@src/engine/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create safe localStorage adapter and deserializeBillConfig parse boundary</name>
  <files>
    src/storage/localStorageAdapter.ts
    src/storage/deserializeBillConfig.ts
  </files>
  <action>
Create the `src/storage/` directory and two files:

**1. `src/storage/localStorageAdapter.ts`** — A `StateStorage`-compatible object (`getItem`, `setItem`, `removeItem`) that wraps every native `localStorage` call in try/catch. This is the ONLY place in the app that touches `localStorage` directly (other than the existing `useOnboarding` hook, which is untouched in this phase).

Implementation:
- `getItem(name: string): string | null` — try `localStorage.getItem(name)`, catch returns `null`
- `setItem(name: string, value: string): void` — try `localStorage.setItem(name, value)`, catch logs `console.warn('[storage] setItem failed:', name, e)` and returns silently
- `removeItem(name: string): void` — try `localStorage.removeItem(name)`, catch ignores

Export the object as `safeLocalStorage`.

**2. `src/storage/deserializeBillConfig.ts`** — A single function `deserializeBillConfig(raw: unknown): BillConfig` that takes the output of `JSON.parse` and re-applies branded type constructors:
- Import `cents`, `personId`, `itemId` from `../engine/types`
- Import `BillConfig`, `Assignments` types from `../engine/types`
- Cast `raw` to an intermediate unbranded shape (plain objects with `string`/`number` fields)
- Reconstruct `people` array: map each entry through `personId(p.id)`
- Reconstruct `items` array: map each entry, applying `itemId(i.id)` and `cents(i.priceCents)`
- Reconstruct `assignments` record: iterate `Object.entries`, apply `itemId(key)` and `personId` to each value element
- Reconstruct `tip` and `tax`: apply `cents(amountCents)` and cast `method` as `'equal' | 'proportional'`
- Return the fully-typed `BillConfig`

Follow the exact implementation from the RESEARCH.md Pattern 3 code example. Do NOT add any validation beyond type reconstruction — the engine's own validation (in `computeSplit`) handles invalid data.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors in the new files.
  </verify>
  <done>
Both files exist, export their respective symbols, and compile without TypeScript errors. `safeLocalStorage` has getItem/setItem/removeItem methods with try/catch. `deserializeBillConfig` imports branded type constructors from engine/types and returns a properly typed BillConfig.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create round-trip test for deserializeBillConfig</name>
  <files>
    src/storage/deserializeBillConfig.test.ts
  </files>
  <action>
Create `src/storage/deserializeBillConfig.test.ts` — a pure function test that runs in the existing `node` environment (no jsdom needed).

Import `deserializeBillConfig` from `./deserializeBillConfig`, `computeSplit` from `../engine/engine`, and branded constructors `cents`, `personId`, `itemId` from `../engine/types`.

Write these test cases:

1. **Round-trip produces identical computeSplit result** — Create a realistic `BillConfig` with 2 people, 2 items (different prices), assignments (one shared, one solo), non-zero tip (200 cents, equal), non-zero tax (100 cents, proportional). Run `JSON.stringify(original)` then `JSON.parse(serialized)` then `deserializeBillConfig(parsed)`. Call `computeSplit` on both original and deserialized configs. Assert `expect(deserializedResult).toEqual(originalResult)`.

2. **Handles empty bill** — Create a BillConfig with empty people, empty items, empty assignments, zero tip, zero tax. Round-trip through JSON and deserialize. Assert `computeSplit(deserialized).ok` is `true` and `results` is an empty array.

3. **Preserves quantity field** — Create a BillConfig with one item that has `quantity: 3`. Round-trip and assert `deserialized.items[0].quantity === 3`.

4. **Preserves assignment mapping** — Create a BillConfig with 2 items and 3 people, each item assigned to different people. Round-trip and assert the assignment keys are ItemId-typed and values contain correct PersonId arrays.

Do NOT test localStorage directly — this is a pure function test.
  </action>
  <verify>
Run `npx vitest run src/storage/deserializeBillConfig.test.ts` — all tests pass.
  </verify>
  <done>
All 4 test cases pass. The round-trip test proves that branded types survive JSON serialization and the engine produces identical results from deserialized data.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run src/storage/` passes all tests
3. `src/storage/localStorageAdapter.ts` exports `safeLocalStorage` object
4. `src/storage/deserializeBillConfig.ts` exports `deserializeBillConfig` function
</verification>

<success_criteria>
- Safe localStorage adapter exists and wraps all native localStorage calls in try/catch
- deserializeBillConfig correctly reconstructs branded types from JSON.parse output
- Round-trip test proves computeSplit produces identical results on deserialized data
- Zero type errors across the project
</success_criteria>

<output>
After completion, create `.planning/phases/06-persistence-foundation/06-01-SUMMARY.md`
</output>
