---
phase: 04-polish
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/store/billStore.ts
  - src/hooks/useUndoDelete.ts
  - src/components/shared/UndoToast.tsx
  - src/components/people/PeoplePanel.tsx
  - src/components/items/ItemsPanel.tsx
autonomous: false

must_haves:
  truths:
    - "Deleting a person removes them immediately and shows an undo toast at the bottom"
    - "Deleting an item removes it immediately and shows an undo toast at the bottom"
    - "Clicking Undo within 5 seconds restores the deleted person/item AND their assignments"
    - "Toast auto-dismisses after 5 seconds if Undo is not clicked"
    - "If a second delete happens while a toast is showing, the first toast is replaced (first undo opportunity lost)"
    - "Toast message includes assignment count warning: 'Deleted Alice (had 3 items assigned)'"
    - "Undo button is keyboard-reachable (real button element in the tab order)"
  artifacts:
    - path: "src/store/billStore.ts"
      provides: "restorePerson and restoreItem store actions"
      contains: "restorePerson"
    - path: "src/hooks/useUndoDelete.ts"
      provides: "Undo snapshot state management hook with 5-second timer"
      contains: "useUndoDelete"
    - path: "src/components/shared/UndoToast.tsx"
      provides: "Interactive toast component with Undo button"
      contains: "aria-live"
  key_links:
    - from: "src/components/people/PeoplePanel.tsx"
      to: "src/hooks/useUndoDelete.ts"
      via: "useUndoDelete hook for person deletion snapshots"
      pattern: "useUndoDelete"
    - from: "src/components/items/ItemsPanel.tsx"
      to: "src/hooks/useUndoDelete.ts"
      via: "useUndoDelete hook for item deletion snapshots"
      pattern: "useUndoDelete"
    - from: "src/hooks/useUndoDelete.ts"
      to: "src/store/billStore.ts"
      via: "restorePerson/restoreItem actions called on undo"
      pattern: "restorePerson|restoreItem"
---

<objective>
Implement the undo toast deletion safety system: when a user deletes a person or item, it disappears immediately but a toast appears at the bottom with an Undo button. Tapping Undo within 5 seconds restores the entity and all its assignments. Includes a human verification checkpoint to confirm the complete polish phase works on mobile.

Purpose: Prevent accidental data loss when users mis-tap the delete button at a restaurant table, following the Gmail-style undo pattern locked in CONTEXT.md.
Output: New store actions (restorePerson, restoreItem), useUndoDelete hook, UndoToast component, wired into PeoplePanel and ItemsPanel.
</objective>

<execution_context>
@/Users/shantnupatil/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantnupatil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-polish/04-CONTEXT.md
@.planning/phases/04-polish/04-RESEARCH.md
@.planning/phases/04-polish/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store restore actions + useUndoDelete hook + UndoToast component</name>
  <files>
    src/store/billStore.ts
    src/hooks/useUndoDelete.ts
    src/components/shared/UndoToast.tsx
  </files>
  <action>
**billStore.ts — Add restorePerson and restoreItem actions:**

1. Add to `BillState` interface:
```typescript
restorePerson: (person: Person, assignments: Record<ItemId, PersonId[]>) => void;
restoreItem: (item: Item, assignedIds: PersonId[]) => void;
```

2. Add to `stateCreator`:

`restorePerson(person: Person, assignments: Record<ItemId, PersonId[]>)`:
- Guard: only restore if person ID is NOT already in `state.config.people` (idempotent)
- Push the original `person` object into `state.config.people` (preserves original ID — critical per research pitfall #1)
- Iterate over `assignments` entries. For each `[itemId, personIds]`:
  - Check if `state.config.assignments[itemId]` exists (item may have been deleted while toast was showing)
  - If it exists and the restored person's ID is not already in the array, add it back
- Do NOT call `addPerson()` (that generates a new UUID — the whole point is preserving the original ID for assignment matching)

`restoreItem(item: Item, assignedIds: PersonId[])`:
- Guard: only restore if item ID is NOT already in `state.config.items`
- Push the original `item` object into `state.config.items`
- Set `state.config.assignments[item.id] = assignedIds` (restore full assignment array)
- Filter `assignedIds` to only include PersonIds that still exist in `state.config.people` (a person may have been deleted while the toast was showing)

**useUndoDelete.ts — New hook:**

Create `src/hooks/useUndoDelete.ts`:

```typescript
import { useState, useRef, useCallback, useEffect } from 'react';
import type { Person, PersonId, Item, ItemId } from '../engine/types';

export interface DeletedPerson {
  kind: 'person';
  person: Person;
  /** Snapshot of ALL assignments at delete time (Record<ItemId, PersonId[]>) */
  assignments: Record<string, string[]>;
  /** Count of items this person was assigned to (for toast message) */
  assignedItemCount: number;
}

export interface DeletedItem {
  kind: 'item';
  item: Item;
  /** PersonIds assigned to this item at delete time */
  assignedIds: string[];
}

export type DeletedSnapshot = DeletedPerson | DeletedItem;

const UNDO_TIMEOUT_MS = 5000;

export function useUndoDelete() {
  const [snapshot, setSnapshot] = useState<DeletedSnapshot | null>(null);
  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Cleanup timer on unmount (prevents setState on unmounted component — research pitfall #2)
  useEffect(() => {
    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);

  const scheduleDelete = useCallback((snap: DeletedSnapshot) => {
    // Replace any existing toast — first undo opportunity lost per CONTEXT.md
    if (timerRef.current) clearTimeout(timerRef.current);
    setSnapshot(snap);
    timerRef.current = setTimeout(() => {
      setSnapshot(null);
      timerRef.current = null;
    }, UNDO_TIMEOUT_MS);
  }, []);

  const handleUndo = useCallback(() => {
    if (!snapshot) return;
    if (timerRef.current) clearTimeout(timerRef.current);
    timerRef.current = null;
    const snapshotToRestore = snapshot;
    setSnapshot(null);
    return snapshotToRestore; // Caller performs the restore
  }, [snapshot]);

  const dismiss = useCallback(() => {
    if (timerRef.current) clearTimeout(timerRef.current);
    timerRef.current = null;
    setSnapshot(null);
  }, []);

  /** Build toast message per CONTEXT.md: "Deleted Alice (had 3 items assigned)" */
  function toastMessage(): string {
    if (!snapshot) return '';
    if (snapshot.kind === 'person') {
      const count = snapshot.assignedItemCount;
      const name = snapshot.person.name;
      if (count === 0) return `Deleted ${name}`;
      return `Deleted ${name} (had ${count} item${count !== 1 ? 's' : ''} assigned)`;
    } else {
      const label = snapshot.item.label || 'Unnamed item';
      const count = snapshot.assignedIds.length;
      if (count === 0) return `Deleted ${label}`;
      return `Deleted ${label} (was assigned to ${count} ${count !== 1 ? 'people' : 'person'})`;
    }
  }

  return {
    snapshot,
    visible: snapshot !== null,
    message: toastMessage(),
    scheduleDelete,
    handleUndo,
    dismiss,
  };
}
```

**UndoToast.tsx — New component:**

Create `src/components/shared/UndoToast.tsx`:

```tsx
interface UndoToastProps {
  message: string;
  visible: boolean;
  onUndo: () => void;
  onDismiss: () => void;
}

export function UndoToast({ message, visible, onUndo, onDismiss }: UndoToastProps) {
  return (
    <div
      aria-live="assertive"
      aria-atomic="true"
      role="status"
      className={`fixed bottom-20 inset-x-4 flex items-center justify-between
                  bg-gray-800 text-gray-100 text-sm font-medium px-4 py-3 rounded-xl
                  shadow-lg transition-opacity duration-200
                  ${visible ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'}`}
    >
      <span className="flex-1 mr-3">{message}</span>
      <button
        onClick={onUndo}
        className="text-blue-400 font-semibold min-h-11 px-2 shrink-0"
        aria-label="Undo deletion"
        tabIndex={visible ? 0 : -1}
      >
        Undo
      </button>
      <button
        onClick={onDismiss}
        aria-label="Dismiss"
        className="text-gray-400 min-h-11 min-w-11 flex items-center justify-center shrink-0"
        tabIndex={visible ? 0 : -1}
      >
        ×
      </button>
    </div>
  );
}
```

Key accessibility details:
- `aria-live="assertive"` announces the deletion immediately to screen readers
- Undo button is a real `<button>` — naturally in tab order when visible
- `tabIndex={visible ? 0 : -1}` removes buttons from tab order when toast is hidden (opacity-0)
- `pointer-events-auto` when visible ensures the Undo button is clickable (unlike the copy Toast which is `pointer-events-none`)
- Positioned at `bottom-20` to sit above the tab bar but keep both toasts at the same vertical position (the copy Toast from SummaryPanel is centered; the undo toast spans the width — they won't visually conflict since copy only appears in Split tab and undo only appears in People/Items tabs)
  </action>
  <verify>
1. `npx vitest run` — all existing tests pass. The new store actions and hook are pure additions.
2. Verify `restorePerson` and `restoreItem` exist on the store interface (TypeScript compilation: `npx tsc --noEmit`).
3. Verify `useUndoDelete` hook exports correctly (import check in a scratch test or TypeScript compilation).
  </verify>
  <done>
- billStore has restorePerson and restoreItem actions that preserve original IDs and re-apply assignments
- useUndoDelete hook manages snapshot state, 5-second timer, auto-dismiss, and toast message generation
- UndoToast component renders an accessible interactive toast with Undo and dismiss buttons
- Timer cleanup on unmount prevents memory leaks
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire undo toast into PeoplePanel and ItemsPanel</name>
  <files>
    src/components/people/PeoplePanel.tsx
    src/components/items/ItemsPanel.tsx
  </files>
  <action>
**PeoplePanel.tsx — Wire undo delete for person removal:**

1. Import `useUndoDelete` from `../../hooks/useUndoDelete` and `UndoToast` from `../shared/UndoToast`.
2. Import `useBillStore` additional selectors: add `restorePerson` and `assignments` to the useShallow selector.
3. Initialize: `const undo = useUndoDelete();`
4. Replace the `onRemove` callback in PersonRow. Instead of calling `removePerson(person.id)` directly, create a `handleRemove(personId)` function:
   ```typescript
   function handleRemove(personId: PersonId) {
     const person = people.find((p) => p.id === personId);
     if (!person) return;
     // Count items this person is assigned to (for toast message)
     const assignedItemCount = Object.values(assignments).filter(
       (ids) => ids.includes(personId)
     ).length;
     // Snapshot the full assignments map for restoration
     const assignmentSnapshot: Record<string, string[]> = {};
     for (const [itemId, personIds] of Object.entries(assignments)) {
       if (personIds.includes(personId)) {
         assignmentSnapshot[itemId] = [...personIds];
       }
     }
     // Execute the delete immediately (optimistic)
     removePerson(personId);
     // Schedule undo toast
     undo.scheduleDelete({
       kind: 'person',
       person,
       assignments: assignmentSnapshot,
       assignedItemCount,
     });
   }
   ```
5. Create `handleUndo()`:
   ```typescript
   function handleUndo() {
     const snap = undo.handleUndo();
     if (snap && snap.kind === 'person') {
       restorePerson(snap.person, snap.assignments as any);
     }
   }
   ```
6. Pass `handleRemove` to PersonRow: `onRemove={() => handleRemove(person.id)}`.
7. At the bottom of the return JSX (after the people list div, inside the fragment), render:
   ```tsx
   <UndoToast
     message={undo.message}
     visible={undo.visible}
     onUndo={handleUndo}
     onDismiss={undo.dismiss}
   />
   ```
8. Wrap the return in a fragment `<>...</>` if not already.

**ItemsPanel.tsx — Wire undo delete for item removal:**

1. Import `useUndoDelete` from `../../hooks/useUndoDelete` and `UndoToast` from `../shared/UndoToast`.
2. Import additional from store: add `restoreItem` and `assignments` to the useShallow selector.
3. Initialize: `const undo = useUndoDelete();`
4. Create `handleRemove(itemId)`:
   ```typescript
   function handleRemove(itemId: ItemId) {
     const item = items.find((i) => i.id === itemId);
     if (!item) return;
     const assignedIds = [...(assignments[itemId] || [])];
     // Execute delete immediately
     removeItem(itemId);
     // Schedule undo toast
     undo.scheduleDelete({
       kind: 'item',
       item,
       assignedIds,
     });
   }
   ```
5. Create `handleUndo()`:
   ```typescript
   function handleUndo() {
     const snap = undo.handleUndo();
     if (snap && snap.kind === 'item') {
       restoreItem(snap.item, snap.assignedIds as any);
     }
   }
   ```
6. Pass `handleRemove` to ItemRow: `onRemove={handleRemove}` (ItemRow calls `onRemove(item.id)` already).
7. Render `<UndoToast>` at the bottom of the return JSX (same pattern as PeoplePanel).
8. Wrap return in fragment if needed.

**Important implementation notes:**
- The snapshot captures data BEFORE the store mutation (reading from current `people` and `assignments` arrays)
- `removePerson` and `removeItem` are called immediately — the entity disappears from the UI instantly (Gmail-style optimistic delete)
- The undo toast replaces any existing toast if a second delete happens while one is showing (per CONTEXT.md: first undo opportunity is lost)
- `restorePerson` preserves the original PersonId so assignments map correctly (research pitfall #1)
  </action>
  <verify>
1. `npx vitest run` — all tests pass.
2. `npx tsc --noEmit` — no TypeScript errors.
3. Manual: Add 2 people and 2 items, assign items to people. Delete a person — verify they disappear, toast shows at bottom with assignment count. Click Undo within 5 seconds — verify person reappears with their assignments intact. Wait 5 seconds — verify toast auto-dismisses.
4. Manual: Delete an item — verify toast shows. Click Undo — verify item reappears with assignments.
5. Manual: Delete person A, then immediately delete person B — verify only person B's undo toast is visible (person A's undo is lost).
6. Manual: Verify Undo button is reachable via Tab key (keyboard accessibility).
  </verify>
  <done>
- Deleting a person in PeoplePanel triggers immediate removal + undo toast with assignment count
- Deleting an item in ItemsPanel triggers immediate removal + undo toast with assignment info
- Undo within 5 seconds restores the entity with original ID and all assignments
- Second delete replaces first toast (first undo lost, per CONTEXT.md)
- Toast auto-dismisses after 5 seconds
- Undo button is keyboard-accessible (real button in tab order)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Final polish verification — keyboard, empty states, undo, mobile QA</name>
  <files>none (verification only)</files>
  <action>
Human verification of the complete Phase 4 polish. No code changes — this is a visual/functional checkpoint.

**What was built:** Complete Phase 4 polish: keyboard navigation (arrow keys in tab bar), empty state guidance (all panels + onboarding), undo toast for deletions (people + items), and mobile QA fixes (iOS font-size, touch targets, overscroll).

**How to verify:**

Keyboard navigation:
1. Open app in desktop browser. Press Tab until tab bar is focused.
2. Press ArrowRight — verify it moves to next tab (People to Items to Assign to Split, wraps to People).
3. Press ArrowLeft — verify reverse navigation. Press Home — jumps to People. Press End — jumps to Split.
4. In People tab, type a name and press Enter — verify nothing happens (no auto-submit).
5. Tab to Add button and press Enter — verify person is added.

Onboarding:
6. Clear localStorage (DevTools, Application, Local Storage, clear). Refresh page.
7. Verify splash screen: "SplitCheck", "Split bills fairly", "Start" button.
8. Click Start — verify app loads to People tab.
9. Refresh again — verify splash does NOT appear.

Empty states:
10. With no people added, verify People tab shows "No people added yet" + "Add your first person" button. Click button — verify name input gains focus.
11. With no items, verify Items tab shows empty guidance.
12. With no items, go to Assign tab — verify "No items to assign" + "Go to Items" button. Click — verify switches to Items tab.
13. With no people, go to Assign tab — verify "No people added" + "Go to People" button.

Undo toast:
14. Add 2 people and 2 items. Assign items to people.
15. Delete a person — verify they vanish, toast shows: "Deleted [name] (had N items assigned) — Undo".
16. Click Undo — verify person returns with all assignments intact.
17. Delete person again — wait 5 seconds — verify toast disappears.
18. Delete person A, then immediately delete person B — verify only person B's toast shows.
19. Delete an item — verify undo restores it with assignments.

Mobile QA (test on phone or Chrome DevTools mobile viewport):
20. Focus a text input — verify NO viewport zoom (font-size is 16px).
21. Scroll to the bottom of any panel, then scroll past — verify NO rubber-band bounce on the page body.
22. Verify all remove buttons and quantity steppers feel tappable (at least 44x44px targets).

Resume signal: Type "approved" or describe any issues found.
  </action>
  <verify>Human confirms all 22 verification steps pass or reports issues for correction.</verify>
  <done>All keyboard navigation, empty states, onboarding, undo toast, and mobile QA checks pass human verification.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — full test suite green
2. `npx tsc --noEmit` — zero TypeScript errors
3. Full keyboard navigation in tab bar (ArrowLeft/Right, Home/End, wrapping)
4. No Enter-to-submit in People name input
5. Empty states visible in all four panel contexts when prerequisites missing
6. Onboarding splash on first visit only
7. Undo toast for person and item deletion with 5-second auto-dismiss
8. Undo restores entity + assignments with correct original IDs
9. Second delete replaces first toast
10. All inputs >= 16px font-size
11. No body overscroll bounce
12. Touch targets >= 44px
</verification>

<success_criteria>
- Undo toast appears on every person/item deletion with correct assignment count message
- Undo within 5 seconds restores entity + assignments perfectly (original IDs preserved)
- Toast auto-dismisses after 5 seconds; second delete replaces first toast
- Undo button is keyboard-reachable
- Human verifier approves the complete polish: keyboard nav, empty states, onboarding, undo, mobile QA
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish/04-02-SUMMARY.md`
</output>
