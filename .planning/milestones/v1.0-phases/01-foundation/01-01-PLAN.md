---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - tsconfig.app.json
  - tsconfig.node.json
  - vite.config.ts
  - index.html
  - src/main.tsx
  - src/App.tsx
  - src/vite-env.d.ts
  - src/engine/types.ts
autonomous: true
requirements:
  - ASGN-02
  - TPTX-02
  - TPTX-04
  - SUMM-02

must_haves:
  truths:
    - "Project builds and runs with `npm run dev`"
    - "Vitest runs with `npx vitest run` and finds zero tests (not an error)"
    - "TypeScript types define the complete data model for bill splitting: items, people, assignments, tip/tax config, engine result with exact and rounded amounts"
    - "All monetary fields are typed as integer cents (branded Cents type)"
    - "Engine result type includes both ok/error discriminated union"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies: react, typescript, vite, tailwindcss, zustand, vitest, immer"
    - path: "vite.config.ts"
      provides: "Vite config with React plugin and Vitest test block"
    - path: "src/engine/types.ts"
      provides: "All TypeScript types: Cents, PersonId, ItemId, Item, Person, Assignments, SplitMethod, BillConfig, PersonResult, EngineResult"
      min_lines: 50
  key_links:
    - from: "vite.config.ts"
      to: "vitest"
      via: "test config block"
      pattern: "test:"
    - from: "src/engine/types.ts"
      to: "engine (plan 01-02)"
      via: "type exports consumed by engine module"
      pattern: "export.*(BillConfig|EngineResult|PersonResult)"
---

<objective>
Scaffold the Vite + React + TypeScript project, install all dependencies (Tailwind CSS 4, Zustand 5, Vitest, immer), configure Vitest, and create the complete TypeScript type definitions that the calculation engine and store will build on.

Purpose: Establish the project foundation and define the data model contract before any logic is written. The types encode all locked decisions (integer cents, discriminated result, per-split includeInTipTax toggle) so subsequent plans build against a verified contract.

Output: A buildable project with all dependencies installed and `src/engine/types.ts` defining every type the engine and store need.
</objective>

<execution_context>
@/Users/shantnupatil/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantnupatil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Vite project and install all dependencies</name>
  <files>
    package.json
    tsconfig.json
    tsconfig.app.json
    tsconfig.node.json
    vite.config.ts
    index.html
    src/main.tsx
    src/App.tsx
    src/vite-env.d.ts
  </files>
  <action>
    Scaffold a new Vite project with the React + TypeScript template using `npm create vite@latest . -- --template react-ts` (in the current directory since it already exists). If the command fails because the directory is not empty, use a temp directory and move files.

    After scaffolding, install the core dependencies:
    ```
    npm install zustand immer
    npm install -D tailwindcss @tailwindcss/vite vitest
    ```

    Verify installed versions with `npm ls zustand immer tailwindcss vitest` — Zustand should be 5.x, Vitest latest, Tailwind CSS 4.x.

    Configure vite.config.ts:
    - Add the `@tailwindcss/vite` plugin
    - Add the Vitest test configuration block:
      ```typescript
      /// <reference types="vitest/config" />
      import tailwindcss from '@tailwindcss/vite'
      // ... existing react plugin
      export default defineConfig({
        plugins: [react(), tailwindcss()],
        test: {
          globals: true,
          environment: 'node',
        },
      })
      ```

    Add `@import "tailwindcss"` to `src/index.css` (Tailwind CSS 4 style).

    Replace the default App.tsx content with a minimal placeholder:
    ```tsx
    function App() {
      return <div>Expense Splitter</div>
    }
    export default App
    ```

    Ensure `npm run dev` starts without errors and `npx vitest run` completes (0 tests, no errors).
  </action>
  <verify>
    Run `npm run build` — should succeed with zero errors.
    Run `npx vitest run` — should complete with "No test files found" or 0 tests passed (not an error exit code).
    Run `npx tsc --noEmit` — should have zero type errors.
  </verify>
  <done>
    Project builds, Vitest runs, TypeScript compiles, all dependencies installed at correct major versions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create complete TypeScript type definitions for the bill-splitting engine</name>
  <files>src/engine/types.ts</files>
  <action>
    Create `src/engine/types.ts` with all types needed by the engine and store. This file is the data contract for the entire application.

    **Branded types** for type safety (per research recommendation):
    - `Cents`: `number & { readonly __brand: 'Cents' }` — all monetary values
    - `PersonId`: `string & { readonly __brand: 'PersonId' }` — person identifiers
    - `ItemId`: `string & { readonly __brand: 'ItemId' }` — item identifiers
    - Helper constructors: `cents(n: number): Cents` (rounds to nearest integer), `personId(s: string): PersonId`, `itemId(s: string): ItemId`

    **Core data types:**
    - `Item`: `{ id: ItemId; label: string; priceCents: Cents; quantity: number }` — quantity defaults to 1, total cost = priceCents * quantity
    - `Person`: `{ id: PersonId; name: string }`
    - `Assignments`: `Record<ItemId, PersonId[]>` — which people share each item. Empty array or missing key = unassigned.
    - `SplitMethod`: `'equal' | 'proportional'`
    - `TipTaxConfig`: `{ amountCents: Cents; method: SplitMethod; includeZeroFoodPeople: boolean }` — the `includeZeroFoodPeople` flag is the per-split toggle (locked decision: per-split, not global)
    - `BillConfig`: `{ items: Item[]; people: Person[]; assignments: Assignments; tip: TipTaxConfig; tax: TipTaxConfig }`

    **Result types (discriminated union):**
    - `PersonResult`: `{ personId: PersonId; foodCents: number; tipCents: number; taxCents: number; exactTotalCents: number; roundedTotalCents: Cents; surplusCents: number }`
      - Note: `foodCents`, `tipCents`, `taxCents` are integer cents (post largest-remainder distribution). `exactTotalCents` is their sum (always integer since all components are integer). `roundedTotalCents` = `Math.ceil(exactTotalCents)` which equals `exactTotalCents` since it is already integer. Wait — per research, rounding only the final total means we accumulate exact values. But if we use largest-remainder for ALL distributions (shared items, tip, tax), all intermediate values are already integers. The surplus would then be zero. Let me reconsider.
      - Correction: The largest-remainder method produces integer cents for each distribution. So `food + tip + tax` per person is always an integer number of cents. `Math.ceil` of an integer is itself. Surplus would be 0.
      - But the user's locked decision says "round up each person's final total to the nearest cent" and "engine must compute and return the surplus amount." If we use largest-remainder everywhere, the results are already rounded (they're integers), and surplus is 0. This is actually the best outcome — the engine CAN produce surplus when the math requires it, but with fair distribution, surplus is minimal/zero.
      - Keep the types as-is: `exactTotalCents: number` (sum of integer components, so it's an integer), `roundedTotalCents: Cents` (Math.ceil, same value), `surplusCents: number` (0 in most cases). The types support surplus even if the algorithm minimizes it.
    - `EngineSuccess`: `{ ok: true; results: PersonResult[]; totalSurplusCents: number }`
    - `EngineError`: `{ ok: false; reason: 'unassigned_items'; unassignedItemIds: ItemId[] }`
    - `EngineResult`: `EngineSuccess | EngineError`

    Export everything with named exports. No default export.
  </action>
  <verify>
    Run `npx tsc --noEmit` — zero type errors.
    Verify the file exports at least: `Cents`, `PersonId`, `ItemId`, `cents`, `personId`, `itemId`, `Item`, `Person`, `Assignments`, `SplitMethod`, `TipTaxConfig`, `BillConfig`, `PersonResult`, `EngineResult`.
  </verify>
  <done>
    `src/engine/types.ts` exists with all types exported. TypeScript compiles cleanly. Every locked decision from CONTEXT.md is encoded in the types: integer cents (Cents branded type), per-split includeZeroFoodPeople toggle (in TipTaxConfig), discriminated EngineResult with unassigned_items error, PersonResult with exact and rounded amounts plus surplus.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npx vitest run` completes without error
3. `npx tsc --noEmit` reports zero errors
4. `src/engine/types.ts` exists and exports all required types
5. All dependencies at correct major versions: Zustand 5.x, Tailwind 4.x, Vitest latest
</verification>

<success_criteria>
- Buildable Vite + React + TypeScript project with Tailwind, Zustand, Vitest, and immer installed
- Complete type definitions in `src/engine/types.ts` encoding all Phase 1 data contracts
- Zero type errors, zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
